'use strict'


// "배열"
// 순서가 있는 컬렉션을 다뤄야 할 때 객체를 사용하면 순서와 관련된 메서드가 없어 그다지 편리하지 않습니다.
// 객체는 태생이 순서를 고려하지 않고 만들어진 자료구조이기 때문에 
// 객체를 이용하면 새로운 프로퍼티를 기존 프로퍼티 ‘사이에’ 끼워 넣는 것도 불가능합니다.
// 이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조인 배열을 사용할 수 있습니다.



// "배열 선언"
let arr = new Array();
arr = [];

// 대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능합니다.
// 각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있습니다. 이 숫자들은 배열 내 순서를 나타냅니다.
let fruits = ["사과", "오렌지", "자두"];
console.log( fruits[0] ); // 사과
console.log( fruits[1] ); // 오렌지
console.log( fruits[2] ); // 자두

// 같은 방법으로 요소를 수정할 수 있습니다.
fruits[2] = '배'; // 배열이 ["사과", "오렌지", "배"]로 바뀜

// 새로운 요소를 배열에 추가하는 것도 가능합니다.
fruits[3] = '레몬'; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜

// length를 사용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있습니다.
console.log( fruits.length ); // 3

// 배열 요소의 자료형엔 제약이 없습니다.
// 요소에 여러 가지 자료형이 섞여 있습니다.
arr = [ '사과', { name: '이보라' }, true, function() { console.log('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
console.log( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.

// trailing 쉼표
// 배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있습니다.
let fruits2 = [
    "사과",
    "오렌지",
    "자두",
];



// "pop·push와 shift·unshift"
// pop
// 배열 끝 요소를 제거하고, 제거한 요소를 반환합니다.
fruits = ["사과", "오렌지", "배"];
console.log( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
console.log( fruits ); // 사과,오렌지

// push
// 배열 끝에 요소를 추가합니다.
fruits = ["사과", "오렌지"];
fruits.push("배");
console.log( fruits ); // 사과,오렌지,배
// fruits.push(...)를 호출하는 것은 fruits[fruits.length] = ...하는 것과 같은 효과를 보입니다.


// 아래는 배열 앞에 무언가를 해주는 메서드입니다.

// shift
// 배열 앞 요소를 제거하고, 제거한 요소를 반환합니다.
fruits = ["사과", "오렌지", "배"];
console.log( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
console.log( fruits ); // 오렌지,배

// unshift
// 배열 앞에 요소를 추가합니다.
fruits = ["오렌지", "배"];
fruits.unshift('사과');
console.log( fruits ); // 사과,오렌지,배

// push와 unshift는 요소 여러 개를 한 번에 더해줄 수도 있습니다.
fruits = ["사과"];
fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");
// ["파인애플", "레몬", "사과", "오렌지", "배"]
console.log( fruits );



// "반복문"
// for문은 배열을 순회할 때 쓰는 가장 오래된 방법입니다. 순회시엔 인덱스를 사용합니다.
arr = ["사과", "오렌지", "배"];
for (let i = 0; i < arr.length; i++) {
  console.log( arr[i] );
}

// 배열에 적용할 수 있는 또 다른 순회 문법으론 for..of가 있습니다.
// 그런데 for..in은 다음과 같은 특징을 지니기 때문에 배열에 for..in을 사용하면 문제가 발생하므로 되도록 다른 반복문을 사용하시길 바랍니다.
fruits = ["사과", "오렌지", "자두"];
// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  console.log( fruit );
}



// "‘length’ 프로퍼티"
// 배열에 무언가 조작을 가하면 length 프로퍼티가 자동으로 갱신됩니다. length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값입니다.
fruits = [];
fruits[123] = "사과";
console.log( fruits.length ); // 124

// length 프로퍼티의 또 다른 독특한 특징 중 하나는 쓰기가 가능하다는 점입니다.
// 이런 특징을 이용하면 arr.length = 0;을 사용해 아주 간단하게 배열을 비울 수 있습니다.
arr = [1, 2, 3, 4, 5];
arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
console.log( arr ); // [1, 2]
arr.length = 5; // 본래 길이로 되돌려 봅시다.
console.log( arr[3] ); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.



// "다차원 배열"
// 배열 역시 배열의 요소가 될 수 있습니다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부릅니다. 다차원 배열은 행렬을 저장하는 용도로 쓰입니다.
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
console.log( matrix[1][1] ); // 5, 중심에 있는 요소




// "toString"
// 배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환됩니다.
arr = [1, 2, 3];
console.log( arr ); // 1,2,3
console.log( String(arr) === '1,2,3' ); // true





// "요약"
// 배열은 특수한 형태의 객체로, 순서가 있는 자료를 저장하고 관리하는 용도에 최적화된 자료구조입니다.

// 선언 방법:
// // 대괄호 (가장 많이 쓰이는 방법임)
// let arr = [item1, item2...];

// // new Array (잘 쓰이지 않음)
// let arr = new Array(item1, item2...);
// new Array(number)을 호출하면 길이가 number인 배열이 만들어지는데, 이 때 요소는 비어있습니다.
// length 프로퍼티는 배열의 길이를 나타내줍니다. 정확히는 숫자형 인덱스 중 가장 큰 값에 1을 더한 값입니다. 배열 메서드는 length 프로퍼티를 자동으로 조정해줍니다.
// length 값을 수동으로 줄이면 배열 끝이 잘립니다.
// 다음 연산을 사용하면 배열을 데큐처럼 사용할 수 있습니다.

// push(...items) – items를 배열 끝에 더해줍니다.
// pop() – 배열 끝 요소를 제거하고, 제거한 요소를 반환합니다.
// shift() – 배열 처음 요소를 제거하고, 제거한 요소를 반환합니다.
// unshift(...items) – items를 배열 처음에 더해줍니다.
// 아래 방법을 사용하면 모든 요소를 대상으로 반복 작업을 할 수 있습니다.

// for (let i=0; i<arr.length; i++) – 가장 빠른 방법이고 오래된 브라우저와도 호환됩니다.
// for (let item of arr) – 배열 요소에만 사용되는 모던한 문법입니다.
// for (let i in arr) – 배열엔 절대 사용하지 마세요.




















