'use strict'

// 스펙에 추가된 지 얼마 안 된 문법입니다. 구식 브라우저는 폴리필이 필요합니다.

// "옵셔널 체이닝이 필요한 이유"
// 사용자가 여러 명 있는데 그중 몇 명은 주소 정보를 가지고 있지 않다고 가정해봅시다. 
// 이럴 때 user.address.street를 사용해 주소 정보에 접근하면 에러가 발생할 수 있습니다.

let user = {}; // 주소 정보가 없는 사용자
console.log(user.address.street); // TypeError: Cannot read property 'street' of undefined

// 명세서에 ?.이 추가되기 전엔 이런 문제들을 해결하기 위해 && 연산자를 사용하곤 했습니다.
// 중첩 객체의 특정 프로퍼티에 접근하기 위해 거쳐야 할 구성요소들을 AND로 연결해 
// 실제 해당 객체나 프로퍼티가 있는지 확인하는 방법을 사용했었죠. 
// 그런데 이렇게 AND를 연결해서 사용하면 코드가 아주 길어진다는 단점이 있습니다.
let user = {}; // 주소 정보가 없는 사용자
console.log( user && user.address && user.address.street ); // undefined, 에러가 발생하지 않습니다




// "옵셔널 체이닝의 등장"
// ?.은 ?.'앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.
// 설명이 장황해지지 않도록 지금부턴 평가후 결과가 null이나 undefined가 아닌 경우엔 값이 ‘있다’, '존재한다’라고 표현하겠습니다.
let user = {}; // 주소 정보가 없는 사용자
console.log( user?.address?.street ); // undefined, 에러가 발생하지 않습니다.

// 위 예시를 통해 우리는 ?.은 ?. ‘앞’ 평가 대상에만 동작되고, 확장은 되지 않는다는 사실을 알 수 있습니다.

// 옵셔널 체이닝을 남용하지 마세요.
// ?.는 존재하지 않아도 괜찮은 대상에만 사용해야 합니다.
// 사용자 주소를 다루는 위 예시에서 논리상 user는 반드시 있어야 하는데 address는 필수값이 아닙니다. 
// 그러니 user.address?.street를 사용하는 것이 바람직합니다.
// 실수로 인해 user에 값을 할당하지 않았다면 바로 알아낼 수 있도록 해야 합니다.
//  그렇지 않으면 에러를 조기에 발견하지 못하고 디버깅이 어려워집니다.

// ?.앞의 변수는 꼭 선언되어 있어야 합니다.
// 변수 user가 선언되어있지 않으면 user?.anything 평가시 에러가 발생합니다.



// "?.()와 ?.[]"
// ?.은 연산자가 아닙니다. ?.은 함수나 대괄호와 함께 동작하는 특별한 문법 구조체(syntax construct)입니다.
// 함수 관련 예시와 함께 존재 여부가 확실치 않은 함수를 호출할 때 ?.()를 어떻게 쓸 수 있는지 알아봅시다.
// 한 객체엔 메서드 admin이 있지만 다른 객체엔 없는 상황입니다.
// 두 상황 모두에서 user 객체는 존재하기 때문에 admin 프로퍼티는 .만 사용해 접근했습니다.
// 그리고 난 후 ?.()를 사용해 admin의 존재 여부를 확인했습니다.
// user1엔 admin이 정의되어 있기 때문에 메서드가 제대로 호출되었습니다. 
// 반면 user2엔 admin이 정의되어 있지 않았음에도 불구하고 메서드를 호출하면 
// 에러 없이 그냥 평가가 멈추는 것을 확인할 수 있습니다.
let user1 = {
    admin() {
        console.log("관리자 계정입니다.");
    }
}
let user2 = {};
user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();

//.대신 대괄호 []를 사용해 객체 프로퍼티에 접근하는 경우엔 
// ?.[]를 사용할 수도 있습니다. 
// 위 예시와 마찬가지로 ?.[]를 사용하면 객체 존재 여부가 확실치 않은 경우에도 안전하게 프로퍼티를 읽을 수 있습니다.
user1 = {
    firstName: "Violet"
};
user2 = null; // user2는 권한이 없는 사용자라고 가정해봅시다.
let key = "firstName";
console.log( user1?.[key] ); // Violet
console.log( user2?.[key] ); // undefined
console.log( user1?.[key]?.something?.not?.existing); // undefined

// ?.은 delete와 조합해 사용할 수도 있습니다.
delete user?.name; // user가 존재하면 user.name을 삭제합니다.


// ?.은 읽기나 삭제하기에는 사용할 수 있지만 쓰기에는 사용할 수 없습니다.
// ?.은 할당 연산자 왼쪽에서 사용할 수 없습니다.

